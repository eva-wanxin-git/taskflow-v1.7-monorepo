# 🏛️ REQ-009需求分析 - 任务自动化流程

**分析时间**: 2025-11-19 01:20  
**架构师**: AI Architect (Expert Level)  
**需求来源**: 用户反馈  
**优先级**: 🔴 P0（核心工作流）

---

## 📋 需求理解

### 用户需求（原话）
> 任务的逻辑是，当他收到任务的时候，他自己可以更新看板上，把待处理变成进行中，然后完成的时候，他可以提交完成报告，把进行中又变成已完成，同时有一个一键复制完成报告的按钮，当然，待处理任务，可以一键复制提示词

### 需求复述（架构师理解）

**核心流程**:
```
1. 架构师派发任务 → Dashboard显示"待处理"
   ↓
2. 李明领取任务 → 李明自己点击按钮 → "待处理"变成"进行中"
   ↓
3. 李明完成任务 → 李明提交完成报告 → "进行中"自动变成"已完成"
   ↓
4. Dashboard显示"已完成" → 有"一键复制完成报告"按钮
   ↓
5. 用户复制报告 → 粘贴给架构师AI审查
```

**关键按钮**:
- 待处理任务：📋 一键复制提示词
- 进行中任务：🔄 更新进度
- 已完成任务：📄 一键复制完成报告

---

## 🎯 隐含假设识别

### 假设1：李明能访问Dashboard UI
- **影响**: 如果李明是另一个AI对话，他不能"点击按钮"
- **需要确认**: 李明是通过UI操作还是API操作？

### 假设2：完成报告有标准位置
- **影响**: 系统如何知道完成报告在哪里？
- **需要确认**: 完成报告存储在哪里？文件名格式？

### 假设3：状态更新是实时的
- **影响**: Dashboard如何检测状态变化？
- **需要确认**: 轮询？WebSocket？文件监听？

---

## 🤔 架构师追问（3个关键问题）

### 问题1：李明的工作环境是什么？

**A. 另一个Cursor AI对话**（不能操作UI）
```
用户：复制提示词 → 新对话粘贴 → @李明提示词
李明AI：执行任务 → 生成完成报告文件
用户：回到架构师对话 → 粘贴完成报告
```

**B. 同一个对话中切换角色**
```
架构师AI：派发任务
（切换角色）
@fullstack-engineer-system-prompt.md
李明AI：执行任务 → 更新状态（调用API？）
```

**C. Dashboard UI操作**（李明是人类）
```
李明：打开Dashboard → 点击"领取任务"按钮
李明：完成后 → 点击"提交完成"按钮
```

**👉 请问是哪种情况？** 这决定技术方案！

---

### 问题2：完成报告的提交方式？

**方案A：文件约定**
- 李明生成文件：`完成报告-{TASK-ID}.md`
- 系统监听文件创建
- 自动解析并更新状态

**方案B：API提交**
- 李明调用：`POST /api/tasks/{id}/complete`
- 提交完成报告内容
- 自动更新状态

**方案C：用户中转**
- 李明生成完成报告
- 用户复制粘贴给架构师
- 架构师确认后更新

**👉 您更倾向哪种？**

---

### 问题3："一键复制"的技术实现？

**Dashboard UI按钮**:
```javascript
// 待处理任务卡片
<button onclick="copyTaskPrompt('TASK-C-1')">
  📋 一键复制提示词
</button>

// 已完成任务卡片
<button onclick="copyCompletionReport('TASK-C-1')">
  📄 一键复制完成报告
</button>
```

**复制内容从哪来**?
- 提示词：从`📤派发给李明-XXX.md`读取？
- 完成报告：从`完成报告-XXX.md`读取？

**👉 文件位置和命名约定是什么？**

---

## 💡 架构师初步方案（3个选项）

### 方案A：文件监听自动化 🤖 激进

**原理**:
```
李明完成任务 → 生成文件（约定位置/命名）
    ↓
文件监听服务 → 检测新文件
    ↓
自动解析文件 → 提取任务ID
    ↓
更新数据库 → 状态变为"已完成"
    ↓
Dashboard自动刷新 → 显示最新状态
```

**优点**:
- ✅ 完全自动化
- ✅ 李明只需生成文件
- ✅ 不需要手动操作

**缺点**:
- ❌ 需要文件监听服务（额外复杂度）
- ❌ 文件命名必须严格约定
- ❌ 错误处理复杂

**适用场景**: 李明是AI，工作在Cursor对话中

**预估工时**: 8小时

---

### 方案B：API提交流程 ⚖️ 平衡 ⭐ 推荐

**原理**:
```
李明完成任务 → 调用Python脚本
    ↓
脚本调用API → POST /api/tasks/{id}/complete
    ↓
API更新数据库 → 状态变为"已完成"
    ↓
Dashboard轮询 → 每5秒检查一次
    ↓
显示最新状态 + "一键复制报告"按钮
```

**李明的操作**:
```python
# 李明完成任务后运行
python scripts/提交任务完成.py TASK-C-1 "完成报告-TASK-C-1.md"
```

**Dashboard功能**:
```javascript
// 待处理任务
📋 一键复制提示词（读取派发文件）

// 已完成任务
📄 一键复制完成报告（读取完成报告文件）
```

**优点**:
- ✅ 技术简单（API + 轮询）
- ✅ 流程清晰（脚本提交）
- ✅ 可控性强（审查后再提交）

**缺点**:
- ⚠️ 李明需要运行脚本（半自动）

**适用场景**: 李明是AI，通过脚本操作

**预估工时**: 4小时 ⭐

---

### 方案C：UI完全操作 🖱️ 保守

**原理**:
```
Dashboard显示任务列表
    ↓
李明点击"开始任务"按钮 → 状态变"进行中"
    ↓
李明上传完成报告文件 → 点击"提交完成"
    ↓
系统解析报告 → 状态变"已完成"
    ↓
架构师点击"一键复制"按钮审查
```

**优点**:
- ✅ 用户体验最好（纯UI操作）
- ✅ 适合人类李明

**缺点**:
- ❌ 前端开发量大（文件上传、解析、展示）
- ❌ 不适合AI李明（AI不能点击按钮）

**适用场景**: 李明是人类开发者

**预估工时**: 12小时

---

## 📊 方案对比表

| 维度 | 方案A (文件监听) | 方案B (API提交) ⭐ | 方案C (UI操作) |
|------|-----------------|-------------------|---------------|
| **实现复杂度** | ⭐⭐ 高 | ⭐⭐⭐⭐ 中 | ⭐⭐ 高 |
| **开发工时** | 8h | 4h | 12h |
| **AI友好度** | ⭐⭐⭐⭐⭐ 高 | ⭐⭐⭐⭐⭐ 高 | ⭐⭐ 低 |
| **人类友好度** | ⭐⭐ 低 | ⭐⭐⭐ 中 | ⭐⭐⭐⭐⭐ 高 |
| **可维护性** | ⭐⭐⭐ 中 | ⭐⭐⭐⭐⭐ 高 | ⭐⭐⭐ 中 |
| **可控性** | ⭐⭐ 低 | ⭐⭐⭐⭐⭐ 高 | ⭐⭐⭐⭐ 高 |
| **实时性** | ⭐⭐⭐⭐⭐ 高 | ⭐⭐⭐⭐ 中 | ⭐⭐⭐⭐⭐ 高 |

---

## 🎯 架构师推荐：方案B（API提交）

### 为什么推荐方案B？

1. **适配当前场景** ✅
   - 李明是AI（工作在Cursor对话中）
   - 通过脚本操作最合适
   - 不需要复杂的文件监听

2. **开发成本最优** ✅
   - 4小时 vs 方案A的8小时 vs 方案C的12小时
   - ROI最高

3. **技术最简单** ✅
   - API + 数据库 + Dashboard轮询
   - 都是已有技术，无需新引入
   - 可维护性强

4. **流程可控** ✅
   - 李明通过脚本提交（显式操作）
   - 架构师可以审查后再确认
   - 不会误触发

---

## 🔧 方案B详细设计

### 后端API（2个端点）

#### 1. PUT /api/tasks/{task_id}/start
**功能**: 李明开始任务（待处理→进行中）

```python
@app.put("/api/tasks/{task_id}/start")
async def start_task(task_id: str):
    """开始任务"""
    # 更新数据库
    conn = sqlite3.connect("database/data/tasks.db")
    cursor = conn.cursor()
    cursor.execute("""
        UPDATE tasks 
        SET status = 'in_progress', 
            updated_at = ? 
        WHERE id = ?
    """, (datetime.now().isoformat(), task_id))
    conn.commit()
    conn.close()
    
    return {"success": True, "task_id": task_id, "status": "in_progress"}
```

#### 2. POST /api/tasks/{task_id}/complete
**功能**: 李明提交完成报告（进行中→已完成）

```python
@app.post("/api/tasks/{task_id}/complete")
async def complete_task(
    task_id: str,
    report_path: str  # 完成报告文件路径
):
    """提交任务完成"""
    # 1. 读取完成报告
    with open(report_path, 'r', encoding='utf-8') as f:
        report_content = f.read()
    
    # 2. 更新数据库
    conn = sqlite3.connect("database/data/tasks.db")
    cursor = conn.cursor()
    cursor.execute("""
        UPDATE tasks 
        SET status = 'completed', 
            updated_at = ?,
            metadata = json_set(metadata, '$.completion_report', ?)
        WHERE id = ?
    """, (datetime.now().isoformat(), report_path, task_id))
    conn.commit()
    conn.close()
    
    return {
        "success": True, 
        "task_id": task_id, 
        "status": "completed",
        "report_path": report_path
    }
```

---

### 李明使用的脚本（2个）

#### 脚本1: 开始任务
```python
# scripts/李明开始任务.py TASK-C-1

import sys
import requests

task_id = sys.argv[1]
response = requests.put(f"http://localhost:8877/api/tasks/{task_id}/start")
print(f"✅ 任务{task_id}已开始！")
```

**李明执行**:
```bash
python scripts/李明开始任务.py TASK-C-1
```

#### 脚本2: 提交完成
```python
# scripts/李明提交完成.py TASK-C-1 完成报告-TASK-C-1.md

import sys
import requests

task_id = sys.argv[1]
report_path = sys.argv[2]

response = requests.post(
    f"http://localhost:8877/api/tasks/{task_id}/complete",
    json={"report_path": report_path}
)
print(f"✅ 任务{task_id}已提交完成！")
print(f"📄 完成报告: {report_path}")
```

**李明执行**:
```bash
python scripts/李明提交完成.py TASK-C-1 "完成报告-TASK-C-1.md"
```

---

### Dashboard UI改进（3个功能）

#### 功能1：任务卡片按钮

```javascript
// 待处理任务
<div class="task-card pending">
  <h3>[P0] TASK-C-1: 创建FastAPI主入口</h3>
  <p>描述: ...</p>
  
  <!-- 一键复制提示词按钮 -->
  <button onclick="copyTaskPrompt('TASK-C-1')">
    📋 一键复制提示词
  </button>
</div>

// 进行中任务
<div class="task-card in-progress">
  <h3>[P0] TASK-C-1: 创建FastAPI主入口</h3>
  <p>负责人: 李明</p>
  <p>开始时间: 2025-11-19 09:00</p>
  
  <!-- 可选：更新进度按钮 -->
  <button onclick="updateProgress('TASK-C-1')">
    🔄 更新进度
  </button>
</div>

// 已完成任务
<div class="task-card completed">
  <h3>[P0] TASK-C-1: 创建FastAPI主入口</h3>
  <p>完成时间: 2025-11-19 12:00</p>
  
  <!-- 一键复制完成报告按钮 -->
  <button onclick="copyCompletionReport('TASK-C-1')">
    📄 一键复制完成报告
  </button>
</div>
```

#### 功能2：一键复制提示词

```javascript
async function copyTaskPrompt(taskId) {
  // 从服务器读取派发文档
  const response = await fetch(`/api/tasks/${taskId}/prompt`);
  const data = await response.json();
  
  // 复制到剪贴板
  await navigator.clipboard.writeText(data.prompt);
  
  // 显示提示
  showToast('✅ 提示词已复制！可粘贴给李明AI');
}
```

**后端API**:
```python
@app.get("/api/tasks/{task_id}/prompt")
async def get_task_prompt(task_id: str):
    """获取任务派发提示词"""
    # 约定：提示词文件命名为 📤派发给李明-{TASK-ID系列}.md
    prompt_file = Path(f"📤派发给李明-{task_id}.md")
    
    with open(prompt_file, 'r', encoding='utf-8') as f:
        content = f.read()
    
    return {"task_id": task_id, "prompt": content}
```

#### 功能3：一键复制完成报告

```javascript
async function copyCompletionReport(taskId) {
  // 从服务器读取完成报告
  const response = await fetch(`/api/tasks/${taskId}/report`);
  const data = await response.json();
  
  // 复制到剪贴板
  await navigator.clipboard.writeText(data.report);
  
  // 显示提示
  showToast('✅ 完成报告已复制！可粘贴给架构师审查');
}
```

**后端API**:
```python
@app.get("/api/tasks/{task_id}/report")
async def get_completion_report(task_id: str):
    """获取任务完成报告"""
    # 约定：完成报告命名为 完成报告-{TASK-ID}.md 或 ✅{REQ-ID}-完成报告.md
    
    # 尝试多种命名格式
    possible_names = [
        f"完成报告-{task_id}.md",
        f"✅{task_id}-完成报告.md",
        f"{task_id}-完成报告.md"
    ]
    
    for name in possible_names:
        report_file = Path(name)
        if report_file.exists():
            with open(report_file, 'r', encoding='utf-8') as f:
                content = f.read()
            return {"task_id": task_id, "report": content}
    
    return {"error": "完成报告未找到"}
```

---

### 方案B：平衡方案 ⚖️ 激进

**原理**:
```
架构师派发 → 生成派发文档（约定命名）
    ↓
李明领取 → 点击Dashboard"一键复制提示词"
    ↓
李明执行 → 生成完成报告（约定命名）
    ↓
李明提交 → python scripts/李明提交完成.py TASK-ID 报告路径
    ↓
API更新状态 → Dashboard自动刷新（轮询5秒）
    ↓
用户查看 → 点击"一键复制完成报告"
    ↓
用户粘贴给架构师 → 架构师审查
```

---

### 方案C：最简方案 🎯 保守

**原理**:
```
架构师派发 → 只更新数据库
    ↓
李明领取 → 手动复制派发文档
    ↓
李明完成 → 手动告知架构师
    ↓
架构师确认 → 手动更新状态
```

**优点**:
- ✅ 最简单，无需开发
- ✅ 完全可控

**缺点**:
- ❌ 全手动，效率低
- ❌ 架构师工作量大

**适用场景**: MVP快速验证

**预估工时**: 0小时（当前已实现）

---

## 📊 我的推荐：方案B（API提交）

### 推荐理由

1. **技术成本合理** ✅
   - 4小时开发 vs 完全自动化的价值
   - ROI高

2. **适配AI工作方式** ✅
   - 李明是AI，通过脚本操作最自然
   - 一键复制符合Cursor使用习惯

3. **流程可控** ✅
   - 李明显式提交（不会误操作）
   - 架构师可以审查后确认

4. **可扩展** ✅
   - 未来可以升级到方案A（文件监听）
   - 未来可以升级到方案C（UI操作）

---

## 🚨 等一下，我需要追问！

### ❓ 在给出最终方案前，请回答：

1. **李明的工作环境**:
   - [ ] A. 新Cursor对话（另一个AI）
   - [ ] B. 同对话切换角色
   - [ ] C. Dashboard UI操作（人类）

2. **完成报告位置**:
   - [ ] 项目根目录（如：`完成报告-TASK-C-1.md`）
   - [ ] 指定目录（如：`reports/`）
   - [ ] 其他位置？

3. **文件命名约定**:
   - [ ] `完成报告-{TASK-ID}.md`
   - [ ] `✅{TASK-ID}-完成报告.md`
   - [ ] 其他格式？

4. **最重要：您更看重什么**？
   - [ ] 完全自动化（方案A）
   - [ ] 平衡方案（方案B）⭐
   - [ ] 最简单（方案C）

---

**✋ 请回答这4个问题，我才能给出精确的实施方案和任务拆解！**

---

**架构师**: AI Architect (Expert Level)  
**分析时间**: 2025-11-19 01:20  
**Token**: 127K/1M (12.7%)  
**Dashboard**: http://localhost:8877

