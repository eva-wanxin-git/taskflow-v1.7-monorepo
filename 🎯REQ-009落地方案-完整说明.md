# 🎯 REQ-009任务三态流转 - 落地方案完整说明

**说明时间**: 2025-11-19 04:35  
**说明人**: AI Architect (Expert Level)

---

## 🤔 用户的困惑

```
问题：我发给新Cursor一个任务，他开始执行了，但状态没变成"进行中"

困惑：REQ-009三态流转到底实现了什么？怎么落地？
```

---

## 📋 REQ-009到底实现了什么？

### ✅ 已实现的部分

#### 1. 工具脚本（2个）
```bash
scripts/李明收到任务.py        # 手动调用
scripts/李明提交完成.py        # 手动调用
```

**功能**: 
- ✅ 可以更新数据库状态
- ✅ 可以记录事件
- ✅ 可以触发Dashboard更新

**问题**: 
- ❌ 需要人手动运行
- ❌ 不是自动触发的

#### 2. API端点（2个）
```
PUT /api/tasks/{task_id}/received   # API端点
POST /api/tasks/{task_id}/complete  # API端点
```

**功能**:
- ✅ 脚本调用这些API更新状态
- ✅ Dashboard可以调用更新状态

**问题**:
- ❌ 需要主动调用
- ❌ 不会自动执行

#### 3. Dashboard按钮（2个）
```html
<button>📋 一键复制提示词</button>  <!-- pending状态显示 -->
<button>📄 一键复制完成报告</button> <!-- completed状态显示 -->
```

**功能**:
- ✅ 可以复制任务信息
- ✅ 可以复制报告模板

**问题**:
- ❌ 只是复制，不更新状态
- ❌ 需要配合脚本使用

---

## ❌ REQ-009没有实现什么？

### 没有实现：真正的自动化

**没有实现**:
```
✗ Cursor打开派发文档时自动运行脚本
✗ Cursor开始编码时自动检测并更新状态
✗ Cursor完成任务时自动提交状态
✗ 系统监听文件变化自动触发
```

**为什么没实现**:
- Cursor没有提供插件/扩展API
- 无法监听Cursor的行为
- 无法自动执行系统命令

---

## 🎯 当前的"自动化"本质

### 实际上是"半自动化"

```
REQ-009提供的:
✅ 工具（脚本）
✅ 接口（API）
✅ UI（按钮）

但需要人工:
❌ 记得调用脚本
❌ 在正确的时机
❌ 用正确的参数
```

### 类比

```
就像给你一把电动螺丝刀：
✅ 工具很好用（一键拧螺丝）
✅ 效率很高（比手动快10倍）
❌ 但你还是要记得拿起来用
❌ 它不会自己飞过来帮你拧
```

---

## ✅ 实际可行的落地方案

### 方案A：强制流程规范（当前方案）⭐

**实现方式**:
1. ✅ System Prompt开头强制要求运行接收脚本
2. ✅ System Prompt结尾强制要求运行提交脚本
3. ✅ 派发文档开头明确写接收指令
4. ✅ 派发文档结尾明确写提交指令

**落地效果**:
```
新Cursor收到派发文档
  ↓
加载System Prompt（看到红色警告）
  ↓
看到派发文档开头（明确指令）
  ↓
【应该】运行接收脚本
  ↓
状态更新 ✅
```

**问题**:
- ⚠️ 依赖执行者"看到并执行"
- ⚠️ 如果执行者漏看了，还是不会执行
- ⚠️ 需要架构师监督

---

### 方案B：派发时包含执行指令（改进）

**在派发文档中写**:
```markdown
@另一个Cursor

你好！执行此任务时，请严格按照以下步骤：

## 步骤1（强制）: 运行接收脚本
```bash
python scripts/李明收到任务.py INTEGRATE-002
```
看到"✅ 任务接收成功"再继续

## 步骤2: 开始编码
[任务详情...]

## 步骤3（强制）: 运行提交脚本
```bash
python scripts/李明提交完成.py INTEGRATE-002 --hours <实际>
```
```

**落地效果**:
- ✅ 执行者看到明确的步骤
- ✅ 知道第一步是运行脚本
- ✅ 有明确的命令可以复制

**问题**:
- ⚠️ 还是依赖人工执行
- ⚠️ 如果执行者跳过步骤1，还是会有问题

---

### 方案C：一键派发命令（更好）⭐⭐

**创建智能派发脚本**:
```bash
# 架构师派发任务时运行
python scripts/派发任务.py INTEGRATE-002 fullstack-engineer

# 这个脚本会：
1. 生成派发文档（包含脚本指令）
2. 生成@命令（给新Cursor）
3. 自动更新任务状态为"已派发"
4. 记录派发事件
```

**给新Cursor的消息**:
```markdown
@新Cursor

任务: INTEGRATE-002
文档: @taskflow-v1.7-monorepo/📤INTEGRATE-002-派发文档.md

🚨 第一步强制执行:
```bash
python scripts/李明收到任务.py INTEGRATE-002
```

看到"✅ 任务接收成功"后再开始编码！
```

**落地效果**:
- ✅ 执行者看到简短明确的指令
- ✅ 第一步就是脚本命令
- ✅ 很难漏掉

---

### 方案D：真正的自动化（未来）

**需要实现**:
```python
# 1. Cursor插件
class TaskFlowCursorPlugin:
    def on_document_opened(self, doc):
        """监听派发文档打开"""
        if doc.path.startswith("📤派发给李明"):
            task_id = extract_task_id(doc)
            # 自动运行
            run_script(f"李明收到任务.py {task_id}")
    
    def on_file_saved(self, file):
        """监听完成报告保存"""
        if file.name.startswith("✅") and "完成报告" in file.name:
            task_id = extract_task_id(file)
            # 自动运行
            run_script(f"李明提交完成.py {task_id}")
```

**落地效果**:
- ✅ 打开派发文档自动更新状态
- ✅ 保存完成报告自动提交状态
- ✅ 完全自动化

**问题**:
- ❌ Cursor不支持插件
- ❌ 无法访问Cursor API
- ❌ 当前无法实现

---

## 🚀 当前推荐方案

### 立即可用：方案A + 方案B的组合

#### 架构师派发任务时

**必须做**:
1. ✅ 使用标准派发文档模板
2. ✅ 确保包含接收和提交指令
3. ✅ @派发时明确提醒

**示例派发消息**:
```markdown
@新Cursor

任务: INTEGRATE-002（集成对话历史库，3小时）

文档: @taskflow-v1.7-monorepo/📤派发给李明-集成部署P0任务.md

🚨🚨🚨 极其重要（第一步强制执行）:

```bash
cd taskflow-v1.7-monorepo
python scripts/李明收到任务.py INTEGRATE-002
```

✅ 看到"任务接收成功"后再开始编码
✅ 完成后运行: python scripts/李明提交完成.py INTEGRATE-002 --hours <实际>

现在开始！
```

#### 新Cursor执行者

**看到派发消息后**:
1. 第一件事: 复制并运行接收脚本
2. 看到成功提示
3. 加载System Prompt
4. 开始编码
5. 完成后运行提交脚本
6. 生成完成报告

---

## 📊 当前状态更新机制

### 工作原理

```
┌─────────────────────────────────────────────┐
│ 1. 架构师派发任务                            │
│    └─ 创建派发文档                           │
│    └─ 包含脚本指令                           │
├─────────────────────────────────────────────┤
│ 2. 新Cursor收到任务                         │
│    └─ 看到派发文档                           │
│    └─ 看到"第一步运行脚本"                   │
│    └─ 【人工】复制脚本命令                   │
│    └─ 【人工】运行脚本                       │
│    └─ 脚本调用API更新数据库                  │
│    └─ 状态变为in_progress ✅                │
├─────────────────────────────────────────────┤
│ 3. 执行者编码                                │
│    └─ Dashboard显示"进行中"                  │
│    └─ 架构师可见进度                         │
├─────────────────────────────────────────────┤
│ 4. 执行者完成任务                            │
│    └─ 【人工】运行提交脚本                   │
│    └─ 脚本调用API更新数据库                  │
│    └─ 状态变为completed ✅                  │
│    └─ Dashboard显示"复制完成报告"按钮       │
└─────────────────────────────────────────────┘
```

**关键**: 步骤2和步骤4都需要【人工】运行脚本

---

## 💡 为什么不能真自动？

### 技术限制

```
Cursor是独立进程
├─ 我们无法监听Cursor打开了哪个文件
├─ 我们无法在Cursor中自动执行命令
├─ 我们无法检测Cursor开始编码
└─ 我们无法拦截Cursor的行为

结论: 无法实现"打开文档自动运行脚本"
```

### 只能做到

```
我们能做的:
✅ 提供工具（脚本）
✅ 提供文档（派发文档）
✅ 提供规范（System Prompt）
✅ 提供提醒（红色警告）

我们不能做的:
❌ 强制执行脚本
❌ 自动检测Cursor行为
❌ 拦截Cursor命令
```

---

## 🎯 最实际的落地方案

### 方案：派发时用超明确的格式

**架构师派发格式（标准模板）**:

```markdown
@新Cursor

# 🚨 任务: INTEGRATE-002

## ⚠️ 第1步: 复制下面命令并运行（强制！）

```bash
cd taskflow-v1.7-monorepo
python scripts/李明收到任务.py INTEGRATE-002
```

✅ 等看到"任务接收成功"再继续下一步
✅ 如果不运行，Dashboard状态不会更新

---

## 📋 第2步: 阅读任务详情

@taskflow-v1.7-monorepo/📤派发给李明-集成部署P0任务.md

任务: 集成REQ-003对话历史库功能
工时: 3小时
优先级: P0

详细要求见上面文档

---

## ✅ 第3步: 完成后运行（强制！）

```bash
python scripts/李明提交完成.py INTEGRATE-002 --hours <实际工时>
```

---

现在执行第1步！
```

**关键**:
- 🔴 第一步就是脚本命令
- 🔴 用红色警告强调
- 🔴 说明不运行的后果
- 🔴 命令可以直接复制粘贴

---

## 📊 REQ-009的真实能力

### 它实现了什么

```
✅ 状态管理工具
✅ API接口
✅ UI按钮
✅ 事件记录

本质: 半自动化工具包
```

### 它没实现什么

```
✗ 自动检测Cursor行为
✗ 自动触发脚本执行
✗ 强制执行机制

本质: 不是全自动
```

### 它的价值

```
价值:
✅ 从手动改数据库（2分钟）→ 运行脚本（5秒）
✅ 效率提升24倍
✅ 减少出错
✅ 标准化流程

局限:
⚠️ 依赖人记得用
⚠️ 需要培训和规范
```

---

## 🔧 立即可用的实施方案

### 给用户的建议

**每次派发任务时，用这个格式**:

```markdown
@新Cursor

🚨 INTEGRATE-XXX任务

第1步（强制，先做）:
```bash
python scripts/李明收到任务.py INTEGRATE-XXX
```

第2步: 
@派发文档.md

第3步（完成后强制）:
```bash
python scripts/李明提交完成.py INTEGRATE-XXX --hours <实际>
```

GO!
```

**特点**:
- 🎯 超级简短（5行）
- 🎯 第一句就是脚本命令
- 🎯 无法漏看
- 🎯 可以直接复制粘贴

---

## 💡 未来改进方向

### 改进1: 创建派发助手脚本

```python
# scripts/派发任务.py
def dispatch_task(task_id, executor, message_template):
    """
    智能派发任务
    
    会自动生成:
    1. 简短的@消息（包含脚本命令）
    2. 完整的派发文档
    3. 更新任务状态为"已派发"
    4. 记录派发事件
    """
    
    # 生成@消息
    msg = f"""
@{executor}

🚨 任务: {task_id}

第1步: python scripts/李明收到任务.py {task_id}
第2步: @派发文档.md
第3步: python scripts/李明提交完成.py {task_id} --hours <实际>
"""
    
    print(msg)
    return msg
```

**用法**:
```bash
# 架构师运行
python scripts/派发任务.py INTEGRATE-002 新Cursor

# 自动生成消息，复制发送即可
```

---

### 改进2: Dashboard提醒功能

```javascript
// Dashboard检测逻辑
function checkStaleStatus() {
    // 检测任务状态异常
    tasks.forEach(task => {
        // 如果pending超过2小时
        if (task.status === 'pending' && hoursSince(task.created) > 2) {
            alert(`任务${task.id}已派发2小时，状态还是pending，可能忘记运行接收脚本`);
        }
        
        // 如果in_progress超过8小时
        if (task.status === 'in_progress' && hoursSince(task.started) > 8) {
            alert(`任务${task.id}进行中超过8小时，可能遇到问题或忘记提交`);
        }
    });
}
```

---

### 改进3: Webhook自动化（如果有服务器）

```python
# 如果派发文档在云端
@app.get("/dispatch/{task_id}/open")
def on_dispatch_opened(task_id: str):
    """派发文档被打开时触发"""
    # 自动更新状态
    update_task_status(task_id, "in_progress")
    return {"status": "ok"}

# 派发文档中嵌入
<img src="http://server/dispatch/INTEGRATE-002/open" width="1" height="1"/>
```

---

## 🎯 总结回答用户

### REQ-009实现了什么？

```
✅ 半自动化工具包
   - 脚本工具（快速更新状态）
   - API接口（标准化接口）
   - UI按钮（便捷操作）

✗ 不是全自动
   - 需要人手动运行脚本
   - 无法监听Cursor行为
   - 无法强制执行
```

### 如何落地？

```
当前最佳方案:
1. 派发任务时，消息第一句就是脚本命令
2. System Prompt开头强制要求
3. 派发文档开头明确指令
4. 架构师监督和提醒

未来改进:
- 创建派发助手脚本
- Dashboard异常提醒
- 如果可能，Webhook自动化
```

### 为什么不能真自动？

```
技术限制:
- Cursor是独立软件，我们无法控制
- 无法监听Cursor的文件打开事件
- 无法在Cursor中自动执行命令

只能依赖:
- 规范和流程
- 文档和提醒
- 人的自觉性
```

---

## 🚀 立即行动建议

### 当前INTEGRATE-002/003/007/012

**都已手动更新为"进行中"** ✅

### 未来所有任务

**派发格式**:
```markdown
@新Cursor

🚨 <任务ID>

步骤1: python scripts/李明收到任务.py <任务ID>
步骤2: @派发文档.md  
步骤3: python scripts/李明提交完成.py <任务ID> --hours <实际>
```

**简短、明确、第一句就是命令！**

---

**REQ-009是半自动化工具，不是全自动！需要配合流程规范使用！** 

**但已经比手动好24倍了！** 🎉

**Dashboard**: http://localhost:8877  
**说明时间**: 2025-11-19 04:35

